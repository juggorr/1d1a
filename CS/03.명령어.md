# 소스코드와 명령어

소스코드) 우리가 파이썬으로 작성하는 코드

명령어) 컴퓨터를 작동시키는 정보

**소스코드가 어떻게 명령어가 되는가**

### 고급언어 & 저급언어

- 고급언어
  
  - 사람이 이해하도록 만들어진 언어
  
  - 대부분의 프로그래밍 언어 (Python, Java, C, ...)

- 저급언어
  
  - 컴퓨터가 이해하고 실행할 수 있는 유일한 언어
  
  - 기계어 / 어셈블리어
    
    - 기계어) 0과 1로만 이루어진 컴퓨터가 실제로 실행하는 언어
    
    <img src="https://velog.velcdn.com/images%2Fwoohm402%2Fpost%2F8f545d98-038b-4015-8425-c1ca234c1a8e%2Fimage.png" title="" alt="" width="810">
    
    - 어셈블리어) 기계어를 사람이 읽을 수 있는 형태로 번역한 언어
    
    ![](https://velog.velcdn.com/images/chlvlftn22/post/41965005-31e8-4708-b9e8-03cfb213929a/image.png)

### 컴파일 & 인터프리터

고급 언어를 저급 언어로 변환시켜주는 방식 두 가지

- 컴파일 (C)
  
  - 컴파일러에 의해 변환
  
  - 소스 코드 전체가 변환되어 실행
  
  - 소스 코드 내에 오류가 하나라도 있을 경우 컴파일 불가능
  
  - 컴파일에 의해 소스 코드가 저급언어로 변환된 코드 = 목적 코드

- 인터프리터 (Python)
  
  - 인터프리터에 의해 소스 코드가 한줄 씩 실행
  
  - 소스 코드내에 오류가 있더라도 그 이전 줄까지 실행 가능
  
  - 컴파일 언어에 비해 소요시간이 다소 오래 걸림

**컴파일 언어와 인터프리터 언어는 이분법적인 개념이 아님. 컴파일언어도 인터프리터를 사용하고 반대의 경우도 존재**

### 목적 파일 & 실행 파일

목적 코드로 이루어진 파일 = 목적 파일 / 실행 코드로 이루어진 파일 = 실행 파일

목적 코드가 실행 파일이 되려면 **링킹**이 필요

**링킹** = 목적 코드 내부에 없는 외부 기능들을 연결하는 작업

### 연산 코드 & 오퍼랜드

명령어 = 연산 코드 + 오퍼랜드

- 연산코드
  
  - 명령어가 수행할 연산
  
  - 데이터 전송 / 연산 / 제어 흐름 변경 / 입출력 제어

- 오퍼랜드
  
  - 연산에 사용될 데이터 or 연산에 사용될 데이터가 저장될 위치
  
  - 0 ~ n개까지 존재 가능
  
  - 오퍼랜드의 갯수에 따라 'n-주소 명령어'라고 지칭

### 오퍼랜드의 주소 지정 방식 5가지

1. 즉시 주소 지정 방식

2. 직접 주소 지정 방식

3. 간접 주소 지정 방식

4. 레지스터 주소 지정 방식

5. 레지스터 간접 주소 지정 방식

즉시 주소 지정 방식

- 데이터를 오퍼랜드에 직접 명시

- 데이터를 찾지 않아도 되어서 빠르지만, 저장할 수 있는 데이터의 크기가 한정적

직접 주소 지정 방식

- 오퍼랜드에 메모리에 위치한 유효 주소를 명시

- 메모리 크기만큼 데이터를 저장할 수 있음

간접 주소 지정 방식 **OjO**

- 유효 주소의 주소를 명시

- 유효 주소의 범위가 넓어짐

- 메모리에 두번 접근해야해 느림

*간접 주소 지정 방식을 사용하면 오퍼랜드 비트가 작을 때 유리하다는데 이해가 잘 안됨..*

레지스터 주소 지정 방식

- 필요한 데이터가 저장된 레지스터를 명시

- CPU 내부의 레지스터에 접근하기 때문에 메모리에 접근할 때 보다 빠름

레지스터 간접 주소 지정 방식

- 유효 주소가 저장된 레지스터를 명시

- 메모리에 한 번만 접근
