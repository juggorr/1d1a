# Chapter 11 CPU 스케쥴링



#### 목차

1. CPU 스케쥴링 개요
2. CPU 스케쥴링 알고리즘



## 1. CPU 스케쥴링 개요



#### 프로세스 우선순위



여러개의 프로세스들이 CPU를 사용하려고 할 때, 어떻게 각 프로세스들에게 공정하게 CPU를 배분할 수 있을까?

CPU 사용요청을 먼저한 순으로 CPU 배분을 할 수 있지만 이는 좋은방법이 아님

각각의 프로세스는 **우선순위**를 가지고 있기 때문에 **우선순위**가 높은 프로세스에게 CPU를 배분하는 것이 좋음



- 입출력 집중 프로세스(I/O bound process): 비디오 재생이나 디스크 백업 작업 등 입출력 작업이 많은 프로세스

- CPU 집중 프로세스(CPU bound process): 수학 연산, 컴파일 작업 등 CPU 작업이 많은 프로세스

```
CPU버스트 : CPU를 이용하는 작업
입출력 버스트 : 입출력장치를 기다리는 작업
즉 CPU 집중 프로세스는 CPU버스트가 많은 프로세스, 입출력 집중 프로세스는 입출력 버스트그 많은 프로세스라고 정의할 수 있다.
```



CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 자원을 요구했다면

-> 입출력 집중 프로세스를 가능한 한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고, 그 후에CPU 집중 프로세스에 CPU를 집중적으로 할당시키는게 더 효율적

![image-20221230202650187](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\11.CPU 스케쥴링.assets\image-20221230202650187.png)

위 그림처럼 입출력 작업이 많은(대기 상태가 긴) **입출력 집중 프로세스**를 먼저 CPU 배분을 한 후에 CPU 집중 프로세스에 집중적으로 CPU 할당을 한다. 이러면 입출력 집중 프로세스의 입출력 작업시간에도 다른 프로세스들이 CPU를 사용할 수 있으므로 효율적이다.

![image-20221230202813381](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\11.CPU 스케쥴링.assets\image-20221230202813381.png)

만약 위 처럼 프로세스에 CPU를 분배한다면, 4번쨰 프로세스의 입출력 작업 시간동안 CPU 분배가 없다. 첫번째 그림처럼 3번 프로세스와 4번 프로세스를 바꾸어 입출력 작업 시간동안 다른 프로세스가 CPU를 사용하게 한다면 더 효율적이다.



이렇게 프로세스가 CPU를 사용할 때 **우선순위**가 있고 이는 각 프로세스의 **PCB**에 명시되어있다.



#### 스케줄링 큐



앞서 말했듯이 PCB에 우선순위가 적혀있지만, CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 모든 프로세스의 PCB를 확인하는 것은 비효율적

그래서 운영체제는 이 프로세스들을 **스케줄링 큐**에 담는다.

CPU를 사용하고 싶은 프로세스는 CPU 큐 (준비 큐)

하드 디스크를 사용하고 싶은 프로세스는 하드 디스크 큐

입출력 장치를 사용하고 싶은 프로세스는 입출력 장치 큐 (프린터 큐)

![image-20221230204446895](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\11.CPU 스케쥴링.assets\image-20221230204446895.png)

- 큐는 자료 구조 관점에서 보았을 때 먼저 삽입된 데이터가 먼저 나가는 선입선출 자료 구조이지만, 스케쥴링에서 이야기하는 큐는 반드시 선입선출이 아닐 필요는 없다

- 일반 큐와 다르게 위의 그림처럼 Linked List로 이루어졌고, 이로인해 내부에서 데이터의 순서가 바뀔 수 있다.
- 즉 큐에 늦게 삽입되더라도 우선순위가 높으면 먼저 나갈 수 있다.



![image-20221230205640498](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\11.CPU 스케쥴링.assets\image-20221230205640498.png)

**준비 실행 대기**상태의 프로세스 순환만 확인하면, 위 그림처럼 각 프로세스는 준비상태일 때 준비 큐 대기 상태일 때 대기 큐에 들어가게 된다. 그리고 큐 내부에서 가장 큰 우선순위가 나와서 다음 동작을 진행한다.

![image-20221230210545725](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\11.CPU 스케쥴링.assets\image-20221230210545725.png)

10장에서 배운 프로세스 상태 다이어그램을 위와 같이 더 세밀하게 완성시킬 수 있다.



#### 선점형과 비선점형 스케줄링



현재 A프로세스가 CPU를 사용하고 있다고 가정해보자. 이때 A보다 더 급한 B프로세스가 CPU사용을 요청한다면 두가지의 방법이 있다.

- 현재 사용 사용중인 A프로세스의 CPU 사용을 중지하고, B프로세스에게 CPU를 할당한다.  -> 선점형 스케줄링
- CPU를 사용중인 A프로세스의 작업이 끝난 후에 B프로세스에게 CPU를 할당한다. -> 비선점형 스케줄링



- 선점형 스케줄링 : 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식 
  - 장점 : 한 프로세스의 자원 독점을 막고 프로세스들에게 골고루 자원을 분배가능
  - 단점 : 문맥 교환 과정에서 오버헤드가 발생할 수 있음
- 비선점형 스케줄링 : 하나의 프로세스가 자원을 사용하고 있다면, 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 자원에 끼어들 수 없는 스케줄링 방식
  - 장점 : 문맥 교환 횟수가 선점형 스케줄링보다 적기 때문에 문맥 교환에서 발생하는 오버헤드가 적다.
  - 단점 : 하나의 프로세스가 자원을 사용중이라면 당장 자원을 사용해야하더라도 무작정 기다려야 한다. 모든 프로세스가 골고루 자원을 사용할 수 없다.



## 2. CPU 스케줄링 알고리즘



#### 스케줄링 알고리즘의 종류

- 선입 선처리 스케줄링
- 최단 작업 우선 스케줄링
- 라운드 로빈 스케줄링
- 최소 잔여 시간 우선 스케줄링
- 우선순위 스케줄링
- 다단계 큐 스케줄링
- 다단계 피드백 스케줄링



##### 선입 선처리 스케줄링

- FCFS 스케줄링 (First Come First Served Scheduling)
- 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 처리 방식
- 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 단점이 있음
- 예를들어 17ms 동안 cpu를 이용하는 프로세스A, 5ms 동안 CPU를 이용하는 프로세스B, 2ms 동안 CPU를 이용하는 프로세스C가 순서대로 준비 큐에 삽입됐다면, B프로세스는 5ms 실행하기위해 17ms, C프로세스는 2ms 실행하기위해 22ms(17+5)를 기다려야 한다. 이러한 현상을 호위 효과라고 한다.

##### 최단 작업 우선 스케줄링

- SJF 스케줄링 (Shortest Job First Scheduling)
- 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 비선점형 스케줄링 처리방식
- 디스크 컨트롤러 문제(https://school.programmers.co.kr/learn/courses/30/lessons/42627)



##### 라운드 로빈 스케줄링

- 선입 선처리 스케줄링에 타임 슬아이스라는 개념이 더해진 스케줄링 방식
- 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
- 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링 방식
- 큐에 삽입된 프로세스들은 삽입된 순서대로 CPU를 이용하지만 정해진 시간만큼만 CPU를 사용한다.
- 정해진 시간을 모두 사용한 후에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입된다.
- 만약 타임 슬라이스가 4ms, CPU 사용시간이 A : 11ms, B : 3ms, C: 7ms인 경우 아래와 같이 수행된다.

![image-20221230221426898](C:\Users\SSAFY_ChoiYuTae\Desktop\algorithm-study\CS\11.CPU 스케쥴링.assets\image-20221230221426898.png)



##### 최소 잔여 시간 우선 스케줄링

- SRT 스케줄링 (Shortest Remaning Time Scheduling)
- 최단 작업 우선 스케줄링 알고리즘과 라운드 로빈 스케줄링을 합친 스케줄링 방식
- 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하고, CPU를 사용할 다음 프로세스는 남아있는 작업 시간이 가장 적은 프로세스가 선택됨



##### 우선순위 스케줄링

-  프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식
- 우선순위가 높은 프로세스를 먼저 처리하는 방식이기 때문에 우선순위가 낮은 프로세스는 (준비 큐에 먼저 삽입됐음에도 불구하고) 우선순위가 높은 프로세스들에 의해 실행이 계속 연기될 수 있다. 이를 **기아 **현상 이라고 한다.
- 에이징 : 기아 현상을 방지하기 위한 기법이다. 오랫동한 대기한 프로세스의 우선순위를 점차 증가시키는 방식. 
- 에이징 기법을 적용하면 우선순위가 낮더라도 언젠가는 높은 우선순위가 되므로, 우선순위가 낮아서 마냥 기다리기만 하는 프로세스가 사라짐



##### 다단계 큐 스케줄링

- 우선순위 스케줄링을 업그레이드한 스케줄링 방식
- 우선순위별로 준비 큐를 여러 개 사용하는 방식
- 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리한 후, 우선순위가 가장 높은 큐가 비어 있으면, 그 다음 우선순위 큐에 있는 프로세스들을 처리
- 큐를 여러개 사용하면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해짐
  - 어떤 큐에는 우선순위가 높아야 하는 백그라운드 프로세스들을 삽입할 수 있고
  - 어떤 큐에는 우선순위가 낮아도 무방한 사용자와의 상호작용이 잦은 프로세스를 삽입할 수 있음
- 큐별로 타임 슬라이스를 여러개 지정할 수도 있으며, 큐마다 다른 스케줄링 알고리즘을 사용할 수 있다.
- 프로세스들이 큐 사이를 이동할 수 없기 때문에, 우선순위가 높은 큐에 프로세스가 계속 삽입된다면 기아 현상이 발생할 수 있음



##### 다단계 피드백 큐 스케줄링

- 다단계 큐 스케줄링에서 프로세스들이 큐 사이를 이동 못함으로써 생기는 기아 현상을 방지하기 위해 보완한 스케줄링 방식
- 프로세스들이 큐 사이를 이동 가능
- 새로 준비상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 삽입되고, 일정 시간(타임 슬라이스) 동안 실행됨.
- 타임 슬라이스동안 해당 프로세스가 완료되지 않는다면, 그 다음 우선순위 큐에 삽입되어 실행되며, 점차 낮은 우선순위큐에 삽입되며 실행됨
- 즉 CPU를 비교적 오래 사용해야 하는 CPU 집중 프로세스의 우선순위는 낮아지고
- CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 우선순위가 높은 큐에서 실행된다.
- 또한 프로세스가 큐 사이를 이동할 수 있기 때문에, 낮은 우선순위 큐에 오래 있는 프로세스는 에이징 기법을 적용하여 우선순위가 높은 큐로 이동시켜 기아 현상을 방지 가능
- 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘
