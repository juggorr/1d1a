# 8. 입출력 장치

## 08-1 장치 컨트롤러와 장치 드라이버

```
입출력 장치가 CPU나 메모리보다 다루기가 더 까다롭다.

이유 1. 입출력 장치의 종류가 너무 많음
- 장치마다 속도, 데이터 형식이 모두 다르다
-> 정보를 주고 받는 방식을 규격화하기 어려움

이유 2. 일반적으로 CPU와 메모리의 데이터 전송률은 높은데 입출력 장치는 낮음
- CPU와 메모리는 1초에 수많은 데이터를 주고 받을 수 있지만 입출력 장치는 불가능 -> 통신에 문제!
- 어떤 입출력 장치는 CPU와 메모리에 비해 전송률이 더 큼 -> 이또한 싱크가 안맞는 문제
```

*전송률* : 데이터를 얼마나 빨리 교환할 수 있는지 나타내는 지표

### `장치 컨트롤러`

: 입출력 장치는 컴퓨터에 직접 연결이되지 않고 장치 컨트롤러라는 하드웨어에 연결됨
-> 장치 컨트롤러는 하나 이상의 입출력 장치와 연결

- 장치 컨트롤러의 역할
  
  1. CPU와 입출력 장치 간의 통신 중개
  2. 오류 검출
  3. 데이터 버퍼링

*버퍼링(buffering)* : 전송률이 높은 장치와 낮은 장치 사이에 주고 받는 데이터를 `버퍼`라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법

- 장치 컨트롤러의 구성
  
  1. 데이터 레지스터
     : CPU와 입출력 장치가 주고 받을 데이터가 담긴 레지스터
     
     - 버퍼의 역할
     - 최근에는 RAM을 사용하기도 함
  
  2. 상태 레지스터
     : 입출력장치가 입출력 작업을 할 준비가 되었는지, 입출력 작업이 완료되었는지, 입출력 장치에 오류는 없는지 등의 상태 정보가 저장되는 레지스터
  
  3. 제어 레지스터
     : 입출력 장치가 수행할 내용에 대한 제어 정보와 명령을 저장하는 레지스터
  - 레지스터에 담긴 값들은 버스를 타고 CPU나 다른 입출력 장치로 전달되기도 하고, 장치 컨트롤러에 연결된 입출력 장치로 전달

### `장치 드라이버`

: 장치 컨트롤러의 동작을 감지하고 제어함으로써 장치 컨트롤러가 컴퓨터 내부와 정보를 주고 받을 수 있게 하는 프로그램

- 새로운 장치를 컴퓨터에 연결하기 위해서는 설치가 필요
- 프로그램이기에 실행 과정 중에 메모리에 저장

장치 컨트롤러 : 하드웨어적 통로 / 장치 드라이버 : 소프트웨어적 통로

```
장치 드라이버를 인식하고 실행하는 주체
: 윈도우, macOS와 같은 운영체제

- 운영체제가 기본적으로 제공하는 장치 드라이버가 존재
- 장치 제작자가 따로 제공하기도 한다 -> 이 경우 직접 설치해야만 사용 가능
```

## 08-2 다양한 입출력 방법

크게 3가지의 입출력 방법이 존재한다.

### 1. 프로그램 입출력

: 기본적으로 프로그램 속 명령어로 입출력을 제어하는 방법

- CPU가 프로그램 속 명령어를 실행하는 과정에서 입출력 명령어를 만나면 CPU는 입출력 장치에 연결된 장치 컨트롤러와 상호작용 하면서 입출력 작업을 수행한다.

```
예시) 메모리에 저장된 정보를 하드 디스크에 백업을 하는 상황

1. CPU가 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령을 보냄
2. 하드디스크 컨트롤러는 하드 디스크의 상태를 확인
-> 준비된 상태라면 상태 레지스터에 준비 완료 표시
3. CPU는 주기적으로 상태 레지스터를 확인
-> 준비 상태를 확인하면 백업할 데이터를 데이터 레지스터에 저장
```

<img src="Ch08_assets/2022-12-24-01-41-49-image.png" title="" alt="" width="600">

<img src="Ch08_assets/2022-12-24-01-42-20-image.png" title="" alt="" width="603">

<img src="Ch08_assets/2022-12-24-01-42-46-image.png" title="" alt="" width="600">

#### CPU가 여러 장치 컨트롤러 속 레지스터에 접근하는 방법

1. 메모리 맵 입출력(memory mapped I/O)
   : 메모리에 접근하기 위한 주소 공간과 입출력 장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주
   
    ex) 1024개의 주소공간 = 512개의 메모리 주소 공간 + 512개의 장치 컨트롤러 레지스터 
   
   - 장치 컨트롤러를 메모리 주소 대하듯 작동 -> 명령어가 서로 같음

2. 고정형 입출력(isolated I/O)
   : 메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하는 방법
   
    ex) 1024개의 주소 공간
   
   - 제어 버스에 `메모리 읽기/쓰기`와 `입출력 장치 읽기/쓰기` 선이 따로 존재 -> 각각 1024개의 주소 공간 활용이 가능
     - 메모리에 접근하는 명령어와 입출력 장치에 접근하는 명령어가 서로 다르다!
         <img src="Ch08_assets/2022-12-24-01-49-19-image.png" title="" alt="" width="579">

![](Ch08_assets/2022-12-24-01-52-04-image.png)

### 2. 인터럽트 기반 입출력(Interrupt-Driven I/O)

1. CPU가 입출력 장치에 처리할 내용을 명령하면 입출력 장치가 명령어를 수행하는 동안 CPU는 다른 일을 함

2. 입출력 장치가 CPU에게 인터럽트 요청 신호를 보내면 CPU는 하던 일을 잠시 멈추고 해당 인터럽트를 처리하는 프로그램인 `인터럽트 서비스 루틴`을 실행한 뒤 다시 하던 일로 되돌아온다

    ![](Ch08_assets/2022-12-24-01-56-30-image.png)

위와 같은 인터럽트를 기반으로 하는 입출력을 `인터럽트 기반 입출력` 이라고 한다.

```
폴링(polling)
:입출력 장치의 상태는 어떤지, 처리할 데이터가 있는지 주기적으로 확인하는 방식
- 인터럽트 방식보다 CPU에 부담
```

- 동시에 여러개의 인터럽트가 몰린 경우
  
  - 순차적으로 실행
    
    ex) A의 인터럽트 서비스 루틴 중 B 인터럽트 요청이 와도 무시하고 A를 완료한 후에 B 인터럽트 서비스 루틴을 진행
    
    - 이 경우 A의 우선순위가 B보다 높은 경우
  
  - 우선 순위를 고려하며 실행
    
    - 플래그 레지스터 속 인터럽트 비트가 활성화 되어 있는 경우, 혹은 인터럽트 비트를 비활성화 해도 무시할 수 없는 인터럽트인 `NMI`가 발생한 경우 우선 순위가 높은 인터럽트부터 처리
    
    ex) A의 인터럽트 서비스 루틴 중 우선순위가 높은 B 인터럽트 요청이 오면 A를 중단하고 B 인터럽트 서비스 루틴을 우선적으로 실행

        ![](Ch08_assets/2022-12-24-02-03-23-image.png)

#### 프로그래머블 인터럽트 컨트롤러(PIC)

: 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에 지금 처리해야할 하드웨어 인터럽트는 무엇인지 알려주는 장치

![](Ch08_assets/2022-12-24-02-05-25-image.png)

- 각 핀에는 CPU에 하드웨어 인터럽트 요청을 보낼 수 있는 약속된 하드웨어가 연결 -> 짝이 지어져있음

```
PIC의 인터럽트 처리 과정

1. PIC가 인터럽트 요청을 받음
2. PIC가 우선순위 판별 후 CPU에 인터럽트 요청 신호를 전송
3. CPU는 PIC에 인터럽트 확인 신호 전송
4. PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터 전송
5. CPU는 인터럽트 벡터를 통해 인터럽트 요청 주체 파악 후 해당 인터럽트 서비스 루틴 실행
```

- PIC는 NMI의 우선 순위는 판별하지 않는다 -> NMI는 우선 순위가 최고라 판별이 불필요

### 3. DMA 입출력

- 위 두가지의 입출력의 경우 모두 데이터 이동을 CPU가 주도하고 이동하는 데이터가 반드시 CPU를 거치게 된다 -> CPU에 부담이 커짐

![](Ch08_assets/2022-12-24-02-11-55-image.png)

- DMA 입출력 : 입출력 장치와 메모리가 CPU를 거치지 않고 상호작용하는 입출력 방식
  
  - 이를 위해서 시스템 버스에 연결된 `DMA 컨트롤러`라는 하드웨어가 필요

![](Ch08_assets/2022-12-24-02-16-21-image.png)

```
DMA 입출력 과정

1. CPU는 DMA 컨트롤러에 입출력 장치의 주소, 수행할 연산, 읽거나 쓸 메모리의 주소 등과 같은 정보로 입출력 작업을 명령
2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행
-> 이 때, DMA 컨트롤러는 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 쓴다.
3. 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알림
```

- CPU의 작업 부담이 줄어듦

- DMA 컨트롤러가 시스템 버스를 사용하고 있을 때 CPU는 시스템 버스 사용이 불가하다.
  -> 시스템 버스는 공용 자원(일방 통행)
  -> CPU가 쓰지 않을 때 혹은 허락을 받고 집중적으로 사용한다.

![](Ch08_assets/2022-12-24-02-18-46-image.png)

#### 입출력 버스

: 위의 예시의 경우처럼 DMA 컨트롤러가 2번 시스템 버스를 사용한다.
-> 너무 자주 DMA 컨트롤러가 시스템 버스를 점유하면 CPU가 사용을 못함
-> 이를 방지하기 위해 DMA 컨트롤러와 장치 컨트롤러를 `입출력 버스`라는 별도의 버스로 연결

![](Ch08_assets/2022-12-24-02-20-49-image.png)

- 현대 대부분의 컴퓨터에는 입출력 버스가 존재
- PCI 버스, PCI Express(PCIe) 버스 등 여러 종류의 입출력 버스가 존재함.